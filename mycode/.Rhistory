?sapply
length(5:10)
length(1:5)
testfn1 <- function(arr1, arr2, scl1, scl2) {
return(mapply(testfn2, arr1, arr2, MoreArgs = list(scl1 = scl1, scl2 = scl2)))
}
testfn2 <- function(arrscl1, arrscl2, scl1, scl2) {
return((arrscl1 * scl1) + (arrscl2 * scl2))
}
testfn1(1:5, 6:10, 1, -1)
testfn1(1:5, c(1, 4, 5, 2, 3), 1, -2)
for (i in 1:5) {
print(((1:5)[i] * 1) + (c(1, 4, 5, 2, 3)[i] * -2))
}
library(SmCCNet)
?fastAutoSmCCNet
1*(1:10 > 5) + 2*(1:10 <= 5)
1*(1:10 > 5) + 2*(1:10 < 5)
a <- b <- c <- 0
a
b
2**2
2^2
10^-5
testfn3 <- function {
testfn3 <- function() {
return(c(1, 2, 3))
}
testfn3
testfn3()
a, b, c <- testfn3()
mapply(1:5, 6:10, length)
mapply(length, 1:5, 6:10)
sapply(length, 1:5, 6:10)
sapply(length, list(1:5, 6:10))
sapply(length, list(1=1:5, 2=6:10))
NUll
NULL
length(NULL)
length(NA)
length(Inf)
Inf > 5
mean(c(1:5, Inf))
?dnorm
log(1L5)
log(1:5)
#' logclk(1, 10, 3, -0.1, -0.2, -0.1, 2.1, 3.1)
logclk <- function(state_i, numactive_i, numreactive_i, b01, b02, b03, b11, b12, allbool=F) {
q1 <- exp(b01 + (b11 * numactive_i))
q2 <- exp(b02 + (b12 * numreactive_i))
q3 <- exp(b03)
q4 <- 1 # exp(0) = 1
qsum <- q1 + q2 + q3 + q4
if (!allbool) {
return(log(c(q1, q2, q3, q4)[state_i]/qsum))
} else {
return(log(c(q1, q2, q3, q4)/qsum))
}
# if (state_i == 1) {
#   numerator <- q1
# } else if (state_i == 2) {
#   numerator <- q2
# } else if (state_i == 3) {
#   numerator <- q3
# } else {
#   numerator <- q4
# }
# return(log(numerator/qsum))
}
logclk(1, 10, 3, -0.1, -0.2, -0.1, 2.1, 3.1)
logclk(1, 10, 3, -0.1, -0.2, -0.1, 2.1, 3.1, allbool=T)
sumlogclk(1, 10, 3, -0.1, -0.2, -0.1, 2.1, 3.1, allbool=T)
sum(logclk(1, 10, 3, -0.1, -0.2, -0.1, 2.1, 3.1, allbool=T))
#' Calculate the (log) conditional likelihood (CLK) of I_i given it's neighbors
#'
#' @param state_i The state of node i, must be one of c(1, 2, 3, 4).
#' @param numactive_i The number of active neighbors of node i, integer.
#' @param numreactive_i The number of reactive neighbors of node i, integer.
#' @param b01-b12 current values of b parameters, scalars.
#' @param logbool Whether to return log CLK or CLK, no default
#' @param allbool Whether to return CLK for all states, default=F
#' @returns A scalar (allbool=F) or vector (allbool=T).
#' @examples
#' logclk(1, 10, 3, -0.1, -0.2, -0.1, 2.1, 3.1)
clk <- function(state_i, numactive_i, numreactive_i, b01, b02, b03, b11, b12, logbool, allbool=F) {
q1 <- exp(b01 + (b11 * numactive_i))
q2 <- exp(b02 + (b12 * numreactive_i))
q3 <- exp(b03)
q4 <- 1 # exp(0) = 1
qsum <- q1 + q2 + q3 + q4
qprobs <- c(q1, q2, q3, q4)/qsum
if (logbool) {
qprobs <- log(qprobs)
}
if (!allbool) {
return(qprobs[state_i])
} else {
return(qprobs)
}
# if (state_i == 1) {
#   numerator <- q1
# } else if (state_i == 2) {
#   numerator <- q2
# } else if (state_i == 3) {
#   numerator <- q3
# } else {
#   numerator <- q4
# }
# return(log(numerator/qsum))
}
sum(logclk(1, 10, 3, -0.1, -0.2, -0.1, 2.1, 3.1,logbool=F, allbool=T))
sum(clk(1, 10, 3, -0.1, -0.2, -0.1, 2.1, 3.1,logbool=F, allbool=T))
clk(1, 10, 3, -0.1, -0.2, -0.1, 2.1, 3.1,logbool=F, allbool=T)
i
p1probs[node_i] <- p1/psum
rnorn(100, 0, 1)
rnorm(100, 0, 1)
mean(rnorm(100, 0, 1))
set.seed(42)
x <- rnorm(1000, 0, 1)
mean(x)
sd(x)
mean(x^2)
x_0mean <- x-mean(x)
x_0mean
mean(x_0mean)
sd(x_0mean)
set.seed(42)
x <- rnorm(1000, 0, 3)
x_0mean <- x-mean(x)
mean(x_0mean) # 3.907985e-17
sd(x_0mean)
sum(x_0mean^2)
sum(x_0mean^2)/length(x_0mean)
sd(x_0mean)^2
